/*
 * Copyright (c) 2013-2014 Massachusetts Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package edu.mit.streamjit.util.ilpsolve.lib;

import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Platform;
import org.bridj.Pointer;
import org.bridj.ann.Convention;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;

/**
 * Based on autogenerated code from JNAerator.
 * @author Jeffrey Bosboom <jbosboom@csail.mit.edu>
 * @since 8/5/2013
 */
@Library("lpsolve")
@org.bridj.ann.Runtime(CRuntime.class)
@SuppressWarnings("deprecation")
public final class Bindings {
	private Bindings() {}

	static {
		Platform.addEmbeddedLibraryResourceRoot("edu/mit/streamjit/util/ilpsolve/lib/");
		BridJ.register();
	}

	public static class lprec {}

	/**
	 * Original signature : <code>lprec* make_lp(int, int)</code><br>
	 * <i>native declaration : lp_lib.h:1393</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("make_lp")
	public static Pointer<lprec > makeLp(int rows, int columns) {
		Pointer<lprec> p = Pointer.pointerToAddress(makeLp$2(rows, columns), lprec.class);
		if (p == null)
			throw new OutOfMemoryError("couldn't allocate lprec");
		return p;
	}
	@Convention(Convention.Style.StdCall)
	@Name("make_lp")
	@Ptr
	protected native static long makeLp$2(int rows, int columns);

	/**
	 * Original signature : <code>void delete_lp(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:1406</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("delete_lp")
	public static void deleteLp(Pointer<lprec > lp) {
		deleteLp(Pointer.getPeer(lp));
	}
	@Convention(Convention.Style.StdCall)
	@Name("delete_lp")
	protected native static void deleteLp(@Ptr long lp);

	/**
	 * Original signature : <code>char set_add_rowmode(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:1440</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_add_rowmode")
	public static byte setAddRowmode(Pointer<lprec > lp, byte turnon) {
		return setAddRowmode(Pointer.getPeer(lp), turnon);
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_add_rowmode")
	protected native static byte setAddRowmode(@Ptr long lp, byte turnon);

	/**
	 * Original signature : <code>char set_obj_fn(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:1427</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_obj_fn")
	public static byte setObjFn(Pointer<lprec > lp, Pointer<Double > row) {
		return setObjFn(Pointer.getPeer(lp), Pointer.getPeer(row));
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_obj_fn")
	protected native static byte setObjFn(@Ptr long lp, @Ptr long row);

	/**
	 * Original signature : <code>char set_row(lprec*, int, double*)</code><br>
	 * <i>native declaration : lp_lib.h:1447</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_row")
	public static byte setRow(Pointer<lprec > lp, int rownr, Pointer<Double > row) {
		return setRow(Pointer.getPeer(lp), rownr, Pointer.getPeer(row));
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_row")
	protected native static byte setRow(@Ptr long lp, int rownr, @Ptr long row);

	/**
	 * Original signature : <code>void set_maxim(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:1433</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_maxim")
	public static void setMaxim(Pointer<lprec > lp) {
		setMaxim(Pointer.getPeer(lp));
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_maxim")
	protected native static void setMaxim(@Ptr long lp);
	/**
	 * Original signature : <code>void set_minim(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:1434</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_minim")
	public static void setMinim(Pointer<lprec > lp) {
		setMinim(Pointer.getPeer(lp));
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_minim")
	protected native static void setMinim(@Ptr long lp);

	/**
	 * Original signature : <code>char set_col_name(lprec*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:1552</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_col_name")
	public static byte setColName(Pointer<lprec > lp, int colnr, Pointer<Byte > new_name) {
		return setColName(Pointer.getPeer(lp), colnr, Pointer.getPeer(new_name));
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_col_name")
	protected native static byte setColName(@Ptr long lp, int colnr, @Ptr long new_name);

	/**
	 * Original signature : <code>char set_bounds(lprec*, int, double, double)</code><br>
	 * <i>native declaration : lp_lib.h:1521</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_bounds")
	public static byte setBounds(Pointer<lprec > lp, int colnr, double lower, double upper) {
		return setBounds(Pointer.getPeer(lp), colnr, lower, upper);
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_bounds")
	protected native static byte setBounds(@Ptr long lp, int colnr, double lower, double upper);

	/** <i>native declaration : lp_lib.h</i> */
	public static final int LE = (int)1;
		/** <i>native declaration : lp_lib.h</i> */
	public static final int EQ = (int)3;
		/** <i>native declaration : lp_lib.h</i> */
	public static final int GE = (int)2;

	/**
	 * Original signature : <code>char set_constr_type(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:1465</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_constr_type")
	public static byte setConstrType(Pointer<lprec > lp, int rownr, int con_type) {
		return setConstrType(Pointer.getPeer(lp), rownr, con_type);
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_constr_type")
	protected native static byte setConstrType(@Ptr long lp, int rownr, int con_type);

	/**
	 * Original signature : <code>void set_rh_vec(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:1480</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_rh_vec")
	public static void setRhVec(Pointer<lprec > lp, Pointer<Double > rh) {
		setRhVec(Pointer.getPeer(lp), Pointer.getPeer(rh));
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_rh_vec")
	protected native static void setRhVec(@Ptr long lp, @Ptr long rh);

	/**
	 * Original signature : <code>char set_int(lprec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:1526</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_int")
	public static byte setInt(Pointer<lprec > lp, int colnr, byte must_be_int) {
		return setInt(Pointer.getPeer(lp), colnr, must_be_int);
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_int")
	protected native static byte setInt(@Ptr long lp, int colnr, byte must_be_int);

	/** <i>native declaration : lp_lib.h</i> */
	public static final int NOMEMORY = (int)-2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OPTIMAL = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SUBOPTIMAL = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INFEASIBLE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int UNBOUNDED = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEGENERATE = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NUMFAILURE = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int USERABORT = (int)6;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int TIMEOUT = (int)7;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVED = (int)9;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PROCFAIL = (int)10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PROCBREAK = (int)11;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int FEASFOUND = (int)12;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NOFEASFOUND = (int)13;

	/**
	 * Original signature : <code>int solve(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:1578</i>
	 */
	@Convention(Convention.Style.StdCall)
	public static int solve(Pointer<lprec > lp) {
		return solve(Pointer.getPeer(lp));
	}
	@Convention(Convention.Style.StdCall)
	protected native static int solve(@Ptr long lp);

	/**
	 * Original signature : <code>char get_variables(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:1775</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("get_variables")
	public static byte getVariables(Pointer<lprec > lp, Pointer<Double > var) {
		return getVariables(Pointer.getPeer(lp), Pointer.getPeer(var));
	}
	@Convention(Convention.Style.StdCall)
	@Name("get_variables")
	protected native static byte getVariables(@Ptr long lp, @Ptr long var);

	/** <i>native declaration : lp_lib.h</i> */
	public static final int NEUTRAL = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int CRITICAL = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SEVERE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int IMPORTANT = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NORMAL = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DETAILED = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int FULL = (int)6;

	/**
	 * Original signature : <code>void set_verbose(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:1655</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_verbose")
	public static void setVerbose(Pointer<lprec > lp, int verbose) {
		setVerbose(Pointer.getPeer(lp), verbose);
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_verbose")
	protected native static void setVerbose(@Ptr long lp, int verbose);

	/**
	 * Original signature : <code>char set_outputfile(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:1653</i>
	 */
	@Convention(Convention.Style.StdCall)
	@Name("set_outputfile")
	public static byte setOutputfile(Pointer<lprec > lp, Pointer<Byte > filename) {
		return setOutputfile(Pointer.getPeer(lp), Pointer.getPeer(filename));
	}
	@Convention(Convention.Style.StdCall)
	@Name("set_outputfile")
	protected native static byte setOutputfile(@Ptr long lp, @Ptr long filename);

	@Convention(Convention.Style.StdCall)
	@Name("print_lp")
	public static void printLp(Pointer<lprec > lp) {
		printLp(Pointer.getPeer(lp));
	}
	@Convention(Convention.Style.StdCall)
	@Name("print_lp")
	protected native static void printLp(@Ptr long lp);
}
